#include<iostream>
#include<bits/stdc++.h>
using namespace std;
using namespace std::chrono;
//every state of the 15 puzzle is stored as a stuct
struct Node{
    string state;// the current state of the 15 puzzle represented as a string
    string actionTaken;// the stream of actions taken from initial state to current state
};

string moves="";//This stores the moves from initial configuration to the final configuration
int nodesExpanded=0;// This is the total no of nodes expanded during the bfs search
auto timeTaken=0.0;// This is the total time taken to perform the bfs search
double memoryTaken = 0.0;// This is the runtime memory for bfs
string goalState = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0";

void bfs(Node node){
    string nodeState = (node.state);
    // if the initial state itself is the goal state then no need to perform bfs
    if(node.state == goalState){
        return;
    }
    unordered_set<string> reachedSet; //reachedSet holds the states that have already been seen by bfs algorithm
    reachedSet.insert(nodeState);
    memoryTaken+=((double)sizeof((node.state)))/1024;
    queue<Node> frontier; // frontier is a FIFO queue that dictates the next node to be chosen for expansion
    frontier.push(node);

    while(!frontier.empty()){
        Node currentNode;
        currentNode = frontier.front();
        frontier.pop();
        nodesExpanded+=1;
        string currentState = currentNode.state;
        istringstream currentStateStream(currentState);
        vector<string> currentStateArray;// currentStateArray holds the current state as an array of strings(Each number is represented as a string)
        string currentNumber;
        int currentRow;
        int currentColumn;
        int currentIndex;
        //the while loop generates the currentStateArray from currentState string
        while(getline(currentStateStream, currentNumber, ' ')){
            currentStateArray.push_back(currentNumber);
            if(currentNumber == "0"){
                currentIndex = (int)(currentStateArray.size()-1);
                currentRow = (int)(currentIndex)/4;
                currentColumn = (int)(currentIndex)%4;
            }
        }
        vector<int> rowStates{0, 0, 1, -1};
        vector<int> colStates{1, -1, 0, 0};
        vector<char> move{'R', 'L', 'D', 'U'};
        int newRow;
        int newColumn;
        int newIndex;
        //this loop moves the blank tile in each of the four directions- left,right,down, and up and checks whether the resulting state is seen or not before.
        for(int i =0;i<4;i++){
            newRow = currentRow + rowStates[i];
            newColumn = currentColumn + colStates[i];
            if(newRow >= 0 && newRow <= 3 && newColumn >=0 && newColumn <= 3){
                vector<string> newStateArray = currentStateArray;
                newIndex = (4*newRow) + newColumn;
                swap(newStateArray[currentIndex],newStateArray[newIndex]);
                string newStateString = "";//newStateString represents the new state generated by moving the blank tile
                for(int j = 0; j<newStateArray.size();j++){
                    newStateString.append(newStateArray[j]+" ");
                }
                newStateString.erase(newStateString.size()-1,1);
                //the if does an early goal test. If the newStateString is a goal state string then bfs stops
                if(newStateString == goalState){
                    moves = currentNode.actionTaken;
                    moves.push_back(move[i]);
                    return;
                }
                //this if checks whether newStateString is seen before or not. If not, it is added to the frontier and to the reached set
                if(reachedSet.find(newStateString) == reachedSet.end()){
                    reachedSet.insert(newStateString);
                    Node newStateNode;
                    newStateNode.state = newStateString;
                    string actionString = currentNode.actionTaken;
                    actionString.push_back(move[i]);
                    newStateNode.actionTaken = actionString;
                    memoryTaken+=((double)sizeof(newStateNode))/1024;
                    memoryTaken+=((double)sizeof((newStateNode.state)))/1024;
                    frontier.push(newStateNode);
                }
            }
        }
    }
}

int main(){
    cout<<"Enter the initial board configuration. There should be ONLY a single space between each number"<<endl;
    string initialConfiguration;// intialConfiguration holds the initial configuration of the board
    // This while loop checks whether input size is correct
    while(true){
        getline(cin, initialConfiguration);
        istringstream checkValid(initialConfiguration);// checkValid is used to check whether the input in initialConfiguration is valid
        vector<string> inputArray;// Array of strings for initial board configuration. Each element of array is a number on the board
        string numberString;// A number on the board represented as a string
        while(getline(checkValid, numberString, ' ')){
            inputArray.push_back(numberString);
        }
        if(inputArray.size()!=16){
            cout<<"The board format entered is invalid. Please enter a valid initial configuration."<<endl;
        }
        break;
    }

    Node startNode; // startNode stores the initial configuration
    startNode.state = initialConfiguration;
    startNode.actionTaken = "";
    memoryTaken+=((double)sizeof(startNode))/1024;// memory storage value is incremented whenever a new node corresponding to a new puzzle state is created
    auto start = high_resolution_clock::now();// start is the initial snaphot before bfs starts
    bfs(startNode);
    auto stop = high_resolution_clock::now();// stop is the final snaphot before bfs ends
    duration<double> time_span = duration_cast<duration<double>>(stop - start);// stop - start is the total time taken by bfs
    timeTaken = time_span.count();
    cout<<"Moves: "<<moves<<endl;
    cout<<"Number of Nodes expanded: "<<nodesExpanded<<endl;
    cout<<"Time Taken: "<<timeTaken<<" seconds"<<endl;
    cout<<"Memory Used: "<<memoryTaken<<" kb";
    return 0;
}